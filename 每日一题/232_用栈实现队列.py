
class MyQueue:


    def __init__(self):
        self.A = []
        self.B = []
        

    def push(self, x: int) -> None:
        self.A.append(x)

    def pop(self) -> int:
        peek = self.peek()
        self.B.pop()
        return peek

    def peek(self) -> int:
        if self.B != []: 
            return self.B[-1]
        else:
            if self.A == []:
                return -1
            else:
                while self.A:
                    self.B.append(self.A.pop())
                return self.B[-1]

    def empty(self) -> bool:
        return self.A == [] and self.B == []
        


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()


"""
===========================================
算法解析：用两个栈实现队列
===========================================

问题描述：
使用两个栈实现一个队列的下列操作：
- push(x): 将元素 x 推到队列的末尾
- pop(): 从队列的开头移除并返回元素
- peek(): 返回队列开头的元素
- empty(): 返回队列是否为空

栈的特性：后进先出 (LIFO)
队列的特性：先进先出 (FIFO)

核心思路：
使用两个栈 A 和 B 来模拟队列：
1. 栈 A 用于接收 push 操作（入队）
2. 栈 B 用于处理 pop 和 peek 操作（出队）
3. 当需要出队时，如果栈 B 为空，则将栈 A 中的所有元素逆序转移到栈 B 中

详细解析：

数据结构设计：
- self.A: 输入栈，专门用于接收 push 操作
- self.B: 输出栈，专门用于处理 pop 和 peek 操作

操作流程分析：

1. push(x) 操作：
   - 时间复杂度: O(1)
   - 直接将元素 x 压入栈 A
   - 示例: push(1), push(2), push(3)
     A: [1, 2, 3] (栈顶是3)
     B: []

2. peek() 操作：
   - 平均时间复杂度: O(1) (摊还分析)
   - 如果栈 B 不为空，直接返回栈 B 的栈顶元素（这是队列的队首）
   - 如果栈 B 为空：
     a. 如果栈 A 也为空，返回 -1（队列为空）
     b. 否则，将栈 A 中的所有元素依次弹出并压入栈 B
       这样栈 B 的栈顶就是最早进入队列的元素
   - 示例: 接上例，调用 peek()
     A: [1, 2, 3] -> 全部弹出并压入 B
     B: [3, 2, 1] (栈顶是1，即最早进入的1)
     返回 1

3. pop() 操作：
   - 平均时间复杂度: O(1) (摊还分析)
   - 先调用 peek() 获取队首元素
   - 然后从栈 B 弹出栈顶元素
   - 示例: 接上例，调用 pop()
     返回 1
     B: [3, 2] (栈顶是2)

4. empty() 操作：
   - 时间复杂度: O(1)
   - 当且仅当栈 A 和栈 B 都为空时，队列为空

关键点解释：

1. 为什么需要两个栈？
   - 栈是后进先出，队列是先进先出
   - 单个栈无法直接实现队列，因为出栈顺序与入栈顺序相反
   - 使用两个栈，通过一次"倒腾"操作，可以将顺序反转两次，从而得到先进先出的效果

2. 摊还时间复杂度分析：
   - 每个元素最多经历两次操作：一次压入栈 A，一次从栈 A 弹出并压入栈 B
   - 因此，对于 n 个操作，总时间复杂度是 O(n)，平均每个操作 O(1)

3. 空间复杂度：O(n)，需要存储所有元素

4. 算法正确性证明：
   - 假设元素入队顺序为: e1, e2, e3, ..., en
   - 在栈 A 中顺序为: [e1, e2, e3, ..., en] (en在栈顶)
   - 当需要出队时，将栈 A 全部转移到栈 B:
     B: [en, ..., e3, e2, e1] (e1在栈顶)
   - 此时从栈 B 弹出的顺序是: e1, e2, e3, ..., en
   - 这正是队列的先进先出顺序

示例演示：

操作序列: push(1), push(2), push(3), peek(), pop(), push(4), pop(), pop()

步骤分析:
1. push(1): A=[1], B=[]
2. push(2): A=[1,2], B=[]
3. push(3): A=[1,2,3], B=[]
4. peek(): 
   - B为空，将A全部转移到B: A=[], B=[3,2,1]
   - 返回B栈顶: 1
5. pop():
   - 返回1，B弹出栈顶: B=[3,2]
6. push(4): A=[4], B=[3,2]
7. pop():
   - B不为空，返回B栈顶: 2
   - B弹出栈顶: B=[3]
8. pop():
   - B不为空，返回B栈顶: 3
   - B弹出栈顶: B=[]

最终队列为空，操作顺序符合先进先出。

优化建议：
1. peek() 方法中返回 -1 可能不是最佳设计，更好的做法是抛出异常或返回 None
2. 可以添加 size() 方法返回队列长度
3. 在实际应用中，可以考虑使用 collections.deque 作为栈的实现，性能更好

总结：
这个算法巧妙地利用了两个栈的 LIFO 特性，通过元素转移实现了队列的 FIFO 特性。
关键思想是：当需要出队时，如果输出栈为空，就将输入栈的所有元素逆序转移到输出栈。
这样每个元素最多被移动两次，保证了摊还时间复杂度为 O(1)。
"""
